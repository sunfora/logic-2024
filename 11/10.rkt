#lang scribble/manual
@(require scribble/manual)
@(require scribble-math)
@(require scribble/base)
@(require racket/file)
@(require racket/port)
@(require (only-in net/url 
                   get-pure-port
                   string->url))


@title[
       #:style (with-html5 manual-doc-style)
       #:tag "problem"
       #:version ""
       ]{11.10}

Нормальная форма vs Аппликативная.

Надо для любого n найти терм который различается в более чем n раз.

@section{Решение}

Наш старый друг n 2. Он же 2^n.
Давайте посмотрим как раскрывается аппликативно.

@verbatim {
  1 2
  
  [0] (λf.λx. f x) 2 
  [1] (λx. 2 x) 
  [1] (λx. (λf.λy. f (f y)) x) 
  [2] (λx. (λy. x (x y))) 
  
  2 2
  [0] (λf.λx. f (f x)) 2 
  [1] (λx. 2 (2 x)) 
  [2] (λx. 2 (λy. x (x y))) 
  [3] (λx. (λz. (λy. x (x y)) ((λy. x (x y)) z))) 
  [4] (λx. (λz. (λy. x (x y)) (x (x z)))) 
  [5] (λx. (λz. x (x (x (x z))))) 

  3 2
  [0] (λf.λx. f (f (f x))) 2 
  [1] (λx. 2 (2 (2 x))) 
  [5] (λx. 2 (λz. x (x (x (x z))))) 
  [5] (λx. (λf.λy. f (f y)) (λz. x (x (x (x z))))) 
  [6] (λx. (λy. (λz. x (x (x (x z)))) ((λz. x (x (x (x z)))) y))) 
  [7] (λx. (λy. (λz. x (x (x (x z)))) (x (x (x (x y)))))) 
  [8] (λx. (λy. (x (x (x (x (x (x (x (x y)))))))))) 
  
  4 2
  [0] (λf.λx. f (f (f (f x)))) 2 
  [1] (λx. 2 (2 (2 (2 x)))) 
  [8] (λx. 2 (λy. (x (x (x (x (x (x (x (x y)))))))))) 
  [8] (λx. (λf.λz. f (f z)) (λy. (x (x (x (x (x (x (x (x y)))))))))) 
  [9] (λx. (λz. (λy. (x (x (x (x (x (x (x (x y))))))))) ((λy. (x (x (x (x (x (x (x (x y))))))))) z))) 
  [10] (λx. (λz. (λy. (x (x (x (x (x (x (x (x y))))))))) (x (x (x (x (x (x (x (x z)))))))))) 
  [11] (λx. (λz. (x (x (x (x (x (x (x (x (x (x (x (x (x (x (x (x z)))))))))))))))))) 
}

Мы тут видим чёткий паттерн, для n 2 нужно линейное число редукций.
А конкретно даже мы можем сказать что это будет число 3 * n - 1.

Теперь давайте посмотрим на нормальный вариант.

@verbatim {
  1 2
  
  [0] (λf.λx. f x) 2 
  [1] (λx. 2 x) 
  [1] (λx. (λf.λy. f (f y)) x) 
  [2] (λx. (λy. x (x y))) 
  
  2 2
  [0] (λf.λx. f (f x)) 2 
  [1] (λx. 2 (2 x)) 
  [1] (λx. (λf.λy. f (f y)) (2 x)) 
  [2] (λx. (λy. (2 x) ((2 x) y))) 
  [2] (λx. (λy. ((λf.λz. f (f z)) x) ((2 x) y))) 
  [3] (λx. (λy. (λz. x (x z)) ((2 x) y))) 
  [4] (λx. (λy. x (x ((2 x) y)))) 
  [4] (λx. (λy. x (x (((λf.λt. f (f t)) x) y)))) 
  [5] (λx. (λy. x (x ((λt. x (x t)) y)))) 
  [6] (λx. (λy. x (x (x (x y))))) 

  3 2
  [0] (λf.λx. f (f (f x))) 2 
  [1] (λx. 2 (2 (2 x)))
  [1] (λx. (λf.λy. f (f y)) (2 (2 x)))
  [2] (λx. (λy. (2 (2 x)) ((2 (2 x)) y)))
  [7] (λx. (λy. (x (x (x (x ((2 (2 x)) y)))))))
  [12] (λx. (λy. (x (x (x (x (x (x (x (x y))))))))))

  4 2
  [0] (λf.λx. f (f (f (f x)))) 2
  [1] (λx. 2 (2 (2 (2 x))))
  [2] (λx. (λy. (2 (2 (2 x))) ((2 (2 (2 x))) y)))
  [13] (λx. (λy. (x (x (x (x (x (x (x (x ((2 (2 (2 x))) y)))))))))))
  [24] (λx. (λy. (x (x (x (x (x (x (x (x (x (x (x (x (x (x (x (x y))))))))))))))))))
}

Ну в общем можно тоже заметить паттерн и он примерно такой в дальнейшем: 6*2^k, что вообще говоря экспоненциально.

Ну и получается что у нас начиная с некоторого момента аппликативный порядок будет в более чем в O(n) раз быстрее. До этого момента можно просто взять любое большое выражение. Условно 100500 2.
