#lang scribble/manual
@(require scribble/manual)
@(require scribble-math)
@(require scribble/base)
@(require racket/file)
@(require racket/port)
@(require (only-in net/url 
                   get-pure-port
                   string->url))


@title[
       #:style (with-html5 manual-doc-style)
       #:tag "problem"
       #:version ""
       ]{7.3}

Пусть дано число @${k \in \mathbb{N}}. Известно, что если @${0 \le k < 2^n}, то возможно закодировать @${k} с помощью @${n} цифр 0 и 1.
А как закодировать число, если мы не знаем верхней границы @${n}? Какую лучшую асимптотику длины кодировки относительно @${\log_2 k} вы можете
предложить? Кодировка должна использовать только символы 0 и 1, также код должен быть префиксным (ни один код не является префиксом другого).

@section{Отсылаем пакетами.}

Могу предложить @${O(1)} относительно @${log_2 k}, а конкретно это будет @${2 \cdot log_2 k}.

Будем записывать пары @${\langle k[i], \text{continue?} \rangle}, где @${k[i]} -- @${i}-ый бит числа @${k}, а @${\text{continue?}} это 1, в случае если число еще ``не закончилось'' и 0, если ``да''.

Например, если у нас есть число ``101010100'', то мы его запишем как ``11 01 11 01 11 01 11 01 00''.

Код префиксный, потому что если @${\text{code}(x)} является префиксом @${\text{code}(y)}, то это означает, что почему-то бит @${\text{continue?}} у числа @${y} поставлен в ноль, хотя код числа @${y} больше кода числа @${x} (так как префикс). Так быть конечно не могло.

В целом, есть вариация на тему, можно отсылать не по битику, а сразу пакетами данных. 

В таком случае получится что-то вроде @${
  \frac{
    \text{packet\_sz} + 1
  }
  {
    \text{packet\_sz}
  } \cdot log_2{k} + \text{const}
}.

Ну и выбирая достаточно большой размер пакета, можно очень хорошо приблизиться к единице.

@section{Альтернативно одарённый способ.}

Можно сначала выписать все нули либо все единицы. Потом поставить 1 или 0. Затем выписать число. И наконец добавить либо 0 либо 1.

Условно говоря: 
@itemlist[
  @item{``101'' @${\rightarrow} ``0 1 101 0''}
  @item{``1000001'' @${\rightarrow} ``11 0 1000001 1''}
]

В худшем случае можно оценить асимптотику как @${1.5 \cdot \text{size} + 2}

Код примерно по той же причине префиксный. Представим что нет, попробуем запуститься, получим какой-то бред, что в исходном числе было больше нулей/единиц, чем должно было быть.
